"""Chatloop functionality for khazaddum using `ChatDB`"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_Chatloop.ipynb.

# %% auto 0
__all__ = ['model_name', 'ChatLoop']

# %% ../nbs/04_Chatloop.ipynb 2
from lisette import *
import litellm
from litellm.types.utils import Message
from fastcore.all import *
from dotenv import load_dotenv
import os

from .ChatDB import *
load_dotenv()

# %% ../nbs/04_Chatloop.ipynb 4
#setting up litellm to work with lmstudio
model_name = os.getenv("LM_STUDIO_MODEL_NAME")

litellm.register_model(
    {model_name:{
        "max_tokens": 8192,          # put the model's real context limit
        "input_cost_per_token": 0.0,
        "output_cost_per_token": 0.0,
        "supports_assistant_prefill": False
}})

# %% ../nbs/04_Chatloop.ipynb 12
class ChatLoop:
    """Multi-turn conversational agent with history management"""
    
    def __init__(
        self, 
        db:ChatDatabase,  # database to save the conversation history
        model_name:str,   # model name to use
        sp=None,          # system prompt
        tools=None,       # tools to use
        max_chat_hist=os.getenv("MAX_CHAT_HIST"),  # maximum number of messages to keep in the conversation history
        ):
        
        # Default system prompt encourages multi-turn conversation
        store_attr()

        default_sp = "You are a helpful assistant. Remember the conversation history and provide contextually relevant responses."
        self.sp = self.sp if self.sp else default_sp

        self.chat = Chat(model=model_name, sp=self.sp, tools=self.tools)  #init the chat obj

        self.all_hist = []              # to store the conversation history
        
        # for tracking the turn
        self.turn = 0

        # Track the session
        self.chat_id = None

        self.title = None

    def new_chat(self):
        """Start a new chat session (like ChatGPT's 'New Chat' button)"""
        # Current session is already saved (auto-save in __call__)
        
        # Reset for new session
        self.all_hist = []
        self.chat.hist = []
        self.turn = 0
        self.chat_id = None
        self.title = None
        
        return True
    
    def send(self, q:str, max_steps=os.getenv("MAX_STEPS")):
        """Send only last max_chat_hist to the agent to minimize the context size"""
        try:
            # Get response from the chat agent
            # The Chat object automatically maintains conversation context
            
            self.chat.hist = self.all_hist[-self.max_chat_hist:]   # keep only the last max_chat_hist messages

            old_len = len(self.chat.hist)

            r = self.chat(q, max_steps=max_steps)
            self.turn += 1
            
            # Only extend with messages beyond old_len
            self.all_hist.extend(self.chat.hist[old_len:])

            return r

        except Exception as e:
            print(f"\nError: {e}\n")
            raise

    @property
    def hist(self):
        return self.all_hist
    
    @property
    def json(self):
        return [i.model_dump() if isinstance(i, Message) else i for i in self.all_hist]
    
    def save(self):
        try:
            if self.chat_id is None: # if session id is not present i.e. first time
                self.chat_id = self.db.save_session(
                    session_name=self.title,
                    history=self.json,
                    model_name=self.model_name,
                )
            else: # 2nd time onwards
                self.db.update_session(
                    chat_id=self.chat_id,
                    history=self.json,
                )
            return True
        except Exception as e:
            print(f"\nError: {e}\n")
            return False

    def load_session(self, chat_id):
        if self.chat_id is not None:
            raise ValueError("There is a existing session running. Please save that first.")
        
        session = self.db.load_session(chat_id)
        if session:
            assert session['id'] == chat_id
            self.all_hist = session['history']
            self.chat_id = chat_id 
            self.chat.hist = self.all_hist[-self.max_chat_hist: ]
            self.title = session['session_name']
            self.turn = len(self.all_hist)
            return self.all_hist
        return False

    
    def __call__(self, q:str, max_steps:int=os.getenv("MAX_STEPS")):
        try:
            if self.turn == 0:
                self.title = q
            
            r = self.send(q, max_steps=max_steps)       
            self.save()
            return r
        except Exception as e:
            print(f"\nError: {e}\n")
            raise
    
